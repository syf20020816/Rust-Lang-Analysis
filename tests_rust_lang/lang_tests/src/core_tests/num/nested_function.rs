//! # 内嵌函数 Nested Function
//!
//! 优点：
//!
//! 1. 封装性和私有性：内嵌函数只在其父函数内部可见，而对于外部代码来说是隐藏的。这可以增强代码的封装性和模块化，使得内部逻辑对外部代码是不可见的，提高了代码的安全性和可维护性。
//! 2. 代码复用：通过将功能相似的代码包装在内部函数中，可以避免代码重复。内嵌函数可以被父函数多次调用，提供了一种代码复用的机制。
//! 3. 逻辑清晰性：内嵌函数可以将复杂的逻辑分解成更小的、更易理解的部分。通过将代码分割成逻辑相关的块，可以提高代码的可读性和可理解性。
//!
//! 缺点：
//!
//! 1. 可见范围限制：内嵌函数只能在其父函数内部调用，无法在其它函数或模块中使用。如果需要在其它地方复用该功能，就需要将内嵌函数提取到一个可公开调用的位置。
//! 2. 函数间通信限制：内嵌函数无法直接与父函数外的代码进行交互，因为它们与外部作用域隔离。如果需要与父函数外的代码进行通信，可能需要使用闭包或参数传递等机制。
//! ```txt
//! @author:syf20020816@Outlook.com
//! @date:2023/7/13
//! @version:0.0.1
//! @description:
//! ```


fn outer(data: u32) -> () {
    fn inner(data: u32) -> String {
        println!("inner");
        let res = data.to_string();
        println!("{}", &res);
        res
    }
    inner(data);
}


fn main() {
    outer(56_u32);
}