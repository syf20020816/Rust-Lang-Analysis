# Technical Term

- author : syf20020816@outlook.com
- date : 2023-06-29

## 旋转操作

旋转操作（rotation operation）指的是对二进制数进行循环位移的操作。旋转操作在计算机编程中常常用于位操作、密码学、数据压缩等领域

旋转操作通常涉及两个参数：要旋转的二进制数和旋转的位数。例如，如果我们将 10101100 向左旋转 2 位，则结果应为 10110001。向左旋转意味着最左边的位将移动到最右边，同时保持其它位的相对顺序不变。

同样，如果我们将 10101100 向右旋转 3 位，则结果应为 10010101。向右旋转意味着最右边的位将移动到最左边，同时保持其它位的相对顺序不变。

> note ： 向左旋转变大，向右旋转变小

<img src="https://github.com/syf20020816/Rust-Lang-Analysis/blob/main/imgs/ro_example.png">

## 交换操作

交换操作（swap operation）指的是将二进制数高位与低位进行交换

例如：1011 0101 交换后 0101 1011

## Const Trait

在Rust中，`impl MyTrait`和`impl const MyTrait`之间有一些区别。

1. 功能特性：`impl MyTrait`用于实现一个普通的trait，该trait可以包含任意的方法和关联类型。而`impl const MyTrait`用于实现一个特殊的trait，该trait只能包含具有`const`修饰符的方法。
2. 方法调用：对于`impl MyTrait`实现的trait，其方法可以通过实例对象进行调用，即可以使用动态分发。而`impl const MyTrait`实现的trait中的方法只能通过类型名直接调用，即使用静态分发。
3. 特化常量：`impl MyTrait`可以在实现中使用特定的常量值。对于`impl const MyTrait`，它允许在trait的方法中使用const常量，并保证在编译时进行计算。这可以用于在编译期间优化代码。

需要注意的是，`impl const`是Rust 1.50版本引入的新功能，因此如果你使用较早的Rust版本，可能不支持`impl const`。

## 宏实现(常用形式)

先看问题：为什么要实现三种
1. `impl<'a> const $imp<$u> for &'a $t `
2. `impl const $imp<&$u> for $t `
3. `impl const $imp<&$u> for &$t `

这三种宏实现形式的目的是为了提供更灵活的宏使用方式和代码复用。

1. `impl<'a> const $imp<$u> for &'a $t`：这种形式的宏实现允许将 trait 实现关联到一个引用类型上，并且在编译时进行常量计算。通过这种方式，我们可以对一个引用类型实现常量级的方法。这在某些情况下很有用，特别是当我们需要对引用进行操作但又不想复制实际数据时。
2. `impl const $imp<&$u> for $t`：这种形式的宏实现允许将 trait 实现关联到一个值类型上，并且在编译时进行常量计算。通过这种方式，我们可以在编译时为值类型实现常量级的方法。这对于需要在编译期执行某些操作的场景非常有用，例如在编译时计算某些值或执行某些验证。
3. `impl const $imp<&$u> for &$t`：这种形式的宏实现允许将 trait 实现关联到一个引用类型的引用上，并且在编译时进行常量计算。通过这种方式，我们可以在编译时为引用类型的引用实现常量级的方法。这在需要在编译时操作引用的场景下很有用，例如对多层引用进行操作时。

这三种宏实现形式提供了更多的灵活性和代码复用性，能够满足不同场景下的需求，并且在编译时进行常量计算可以提高性能和代码质量。

## 进制数

进制数是一种表示数字的方式，它决定了数字中各个位置上可以使用的符号和其对应的权重。常见的进制包括二进制（base 2）、十进制（base 10）、八进制（base 8）和十六进制（base 16）。进制数由基数（radix）确定，基数表示一个进制系统中可用的不同符号的数量。

例如，十进制中的基数为 10，因此使用了 0 到 9 的十个数字字符来表示数字。而二进制中的基数为 2，因此只能使用 0 和 1 两个数字字符来表示数字。类似地，八进制的基数为 8，十六进制的基数为 16。

进制数通过使用权重的方式来表示数字。在十进制中，每个数字的权重是以 10 的幂递增的，最右边的数字权重为 10^0，向左依次递增。例如，数字 123 在十进制中表示为 1 * 10^2 + 2 * 10^1 + 3 * 10^0。而在二进制中，每个数字的权重是以 2 的幂递增的，最右边的数字权重为 2^0，向左依次递增。

进制数的选择取决于所需表示的值的特定需求。十进制是最常用的进制，因为它直观且易于理解。二进制常用于计算机科学和数字电路中，因为计算机使用的是二进制逻辑。八进制和十六进制经常用于表示内存地址、字节序列和编码表示等。进制数的范围通常限制在 2 到 36，这是因为该范围内有足够的符号（数字和字母）可以表示各个位上的值，而且涵盖了大多数常见的需求。

## 数字截断

出自源码`fn from_u32(u: u32) -> Self { u as Self }`的思考（将u32转为各种整数类型比如u8，但是若输入的u32大于u8的最大值是否会出现错误？答案：不会，因为采用了数字截断）

使用 `as` 关键字将一个整数类型转换为另外一个整数类型时，如果目标类型无法表示源类型的值范围，会发生截断行为。对于无符号整数类型（比如 `u32` 和 `u8`），截断行为意味着超出目标类型范围的值会被截断，只保留低位部分。

因此，如果将一个大于 `u8` 最大值的 `u32` 值转换为 `u8` 类型，截断行为会让结果等于原始值对 `u8` 取模的结果。例如，如果 `u` 是一个大于 `u8` 最大值的 `u32` 值，那么 `u as u8` 的结果将是 `u % 256`。

这种截断行为并不会引发错误或产生编译时错误，而是由程序员负责确保安全性。在某些情况下，可能需要进行溢出检查或处理。

## match with judge

出自源码：`core/src/num/mod.rs`中的`from_str_radix()`

match 进行匹配时加判断直接跟在后面写即可

```rust
fn main(){
    let src = "+";
    let index = 5;
    match src {
        "+" if index == 5 => {
            println!("first 5")
        }
        _ => {}
    }
}
```

## 位移相比数字计算的优点

左移和右移是位运算中常见的操作，主要用于对二进制数进行移位操作。与数值运算相比，左移和右移具有以下优点：

1. 效率更高：位移操作通常比数值运算更快，因为它们是底层的位级操作，直接对二进制数据进行操作，不涉及乘法、除法等复杂的数学运算。
2. 结果可预测：位移操作的结果是确定的且可预测的，不受机器字长的影响。无论是在32位系统还是64位系统上执行位移，结果都一致。
3. 逻辑清晰：在某些情况下，使用位移操作可以使代码更加直观和易于理解。比如，将一个整数左移 n 位，相当于将该整数乘以 2 的 n 次方；将一个整数右移 n 位，相当于将该整数除以 2 的 n 次方并向下取整。
4. 位掩码操作：位移操作经常与位掩码操作结合使用，用于提取或设置特定的位。通过左移和右移配合使用，可以轻松地实现对指定位的读取、修改或写入。

需要注意的是，左移和右移是位级操作，其结果也是按位计算的。在进行位移操作时，需要明确考虑数据类型和移动的位数，以避免溢出或逻辑错误。

## ^运算和&运算

- ^ : 异 1 同 0 （1^1 = 0 , 0^0 = 0 , 1^0 = 1）
- & : 1 1 other 0 (1&1=1 , 1&0=0 , 0&0=0)

## 无分支算法(branchless algorithm)

`(a + b) / 2` == `((a ^ b) >> 1) + (a & b)`.

例如：

```
a = 5
b = 7
(a+b)/2 = 6
a^b == 101^111 = 010
010 >> 1 = 01
a&b == 101&111 = 101
01 + 101 = 110 == 2+4 = 6
```

